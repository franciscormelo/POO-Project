package antColony;

import java.util.ArrayList;
import java.util.Random;

import graph.Edge;
import graph.Graph;
import simulator.Event;
import simulator.PEC;

/**
 * Class related to the ant move event.
 * @author Group 33
 *
 */

class AntMove extends Event {

	/**
	 * Class Data 
	 */
	public Data data;
	
	/**
	 * Class Graph
	 */
	public Graph graph;
	
	/**
	 * Class Ant
	 */
	public Ant ant;

	/**
	 * Random Class
	 */
	static Random random = new Random();


	/**
	 * AntMove Constructor - Receives the time of the event, an object of type Data, an object of type Ant and an object of type Graph.
	 * @param time Event time
	 * @param data Object of type Data
	 * @param ant Object of type Ant
	 * @param graph Object of type Graph
	 */
	public AntMove(double time, Data data, Ant ant, Graph graph) {
		super(time);
		this.data = data;
		this.ant = ant;
		this.graph = graph;
		this.ant = ant;
	}

	/* (non-Javadoc)
	 * @see simulator.Event#simulateEvent(simulator.PEC)
	 */
	@Override
	public void simulateEvent(PEC pec) {

		ArrayList<Edge> adjList = graph.adjacency(ant.currentNode());
		ArrayList<Edge> setJ = ant.getJ(adjList);


		Edge chosenEdge = null;

		if (setJ.isEmpty()) {

			chosenEdge = adjList.get(random.nextInt(adjList.size()));

			if (chosenEdge.adjnode == graph.nestnode && ant.checkFinish(graph.nbnodes)) {

				ant.addNode(chosenEdge.adjnode);


			} else {

				ant.removeUntilNode(chosenEdge.adjnode);

			}


		} else {

			float[] cijk = new float[setJ.size()];
			float[] prob = new float[setJ.size()];

			float ci = 0;

			for (int i = 0; i < setJ.size(); i++) {

				cijk[i] = (data.alpha + setJ.get(i).pheromones)/(data.beta + setJ.get(i).weight);

				ci += cijk[i];
			}

			for (int j = 0; j < cijk.length; j++) {
				prob[j] = cijk[j]/ci;
			}

			float r = random.nextFloat();

			float c = 0;

			for (int i = 0; i < prob.length; i++) {

				if (i == prob.length - 1) {
					if (r >= c) {
						chosenEdge = setJ.get(i);
						break;
					}
				} else {
					if (r >= c && r < prob[i] + c) {
						chosenEdge = setJ.get(i);
						break;
					}
				}

				c += prob[i];
			}

			ant.addNode(chosenEdge.adjnode);
		}

		double mean = data.delta * chosenEdge.weight;

		double nextTime = time + expRandom(mean);

		if (nextTime <= data.finalinst) {
			pec.addEvPEC(new AntMove(nextTime, data, ant, graph));	
		}
	}

	/* (non-Javadoc)
	 * @see simulator.IEvent#getTime()
	 */
	@Override
	public double getTime() {
		return time;
	}


	/**
	 * Returns an exponential random variable generated by using the inverse of
	 * the cumulative distribution function with mean the values received as parameter.
	 * @param mean Mean value
	 * @return Random variable observation
	 */
	private static double expRandom(double mean) {

		double next = random.nextDouble();
		return -mean*Math.log(1.0-next);
	}

}
